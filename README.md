# Общая информация
Ссылка на [GitHub](https://github.com/a1div0/acme-client "GitHub").

Клиент ACME-протокола используется для автоматического получения сертификата безопасности для вашего сайта. Для бесплатного получения сертификата и автоматического его продления в основном все используют [Let's Encrypt](https://letsencrypt.org/ "Let's Encrypt"). Но и есть другие сервисы, например [Zero SSL](https://zerossl.com/ "Zero SSL"). Он тоже поддерживает ACME-протокол.

Я опирался на две статьи с Хабра ([эту](https://habr.com/ru/company/ispsystem/blog/354420/ "эту") и [эту](https://habr.com/ru/company/ispsystem/blog/413429/ "эту")), а также [RFC8555](https://datatracker.ietf.org/doc/html/rfc8555 "RFC8555"). Но информации в них оказазалось недостаточно, для того, чтобы реализовать собственный вариант модуля. Примерно половину нужной информации потребовалось дополнительно извлечь из нескольких реализаций данного модуля [на других языках](https://letsencrypt.org/ru/docs/client-options/ "на других языках"). Тесты проводил на живом сервисе, поэтому автотестов пока нет. Можете написать и сделать коммит.

Модуль написан под Linux. Рассматривается только вторая версия протокола.

# Установка
Вы можете:
* Клонировать репозиторий:
```shell
git clone https://github.com/a1div0/acme-client.git
```

# Подготовка к работе
## CSR
Предварительно необходимо сформировать запрос на подпись сертификата (Certificate Signing Request) - [CSR](https://en.wikipedia.org/wiki/Certificate_signing_request "CSR"). Этот файл (назовём его `csr.pem`) содержит информацию о вашем домене и организации. А именно там необходимо заполнить следующие поля:
1. Доменное имя (CN) - на которое выпускается сертификат;
2. Организация (O) - полное имя организации, которой принадлежит сайт;
3. Отдел (OU) - подразделение организации, которое занимается выпуском сертификата;
4. Страна (C) - [код](https://ru.wikipedia.org/wiki/ISO_3166-1_alpha-2 "ISO 3166-1 alpha-2") из двух символов, соответствующий стране организации ([список](https://ru.wikipedia.org/wiki/ISO_3166-2 "ISO 3166-2"));
5. Штат/Область (ST) и город (L) - местонахождение организации;
6. email (EMAIL) - почта для связи с организацией.

Сгенерировать такой файл можно с помощью онлайн-генераторов, например [вот](https://csrgenerator.com/ "CSR Generator") и [вот](https://www.reg.ru/ssl-certificate/generate_key_and_csr "Создание запроса на сертификат"). Можно с помощью OpenSSL. Для этого необходимо ввести команды вида:
```
openssl genrsa -out private.key 4096
openssl req -new -key private.key -out domain_name.csr -sha256
```
Далее необходимо ввести указанную выше информацию и запрос готов. Должен получиться текстовый файлик такого вида:
```
-----BEGIN CERTIFICATE REQUEST-----
MIICyDCCAbACAQAwgYIxCzAJBgNVBAYTAlJVMSQwIgYDVQQIDBvQkNC70YLQsNC5
. . .
Mf5rbR8Ok/PfHohVHsOp85mAyTInt7a5H4PHVHb7U8j5aPhc4HarH+LcJhM=
-----END CERTIFICATE REQUEST-----

-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCttTORMQRaZYq2
. . .
QARm4Qu60qmM30MrhtCYOBk=
-----END PRIVATE KEY-----
```

В планах есть автоматизировать процесс создания CSR, так как практически можно продлять сертификат им же, но лучше создавать каждый раз новый.

## Добавить и настроить модуль
Модуль возвращает объект с процедурами:

### Init
```
init(settings)
```
Данная процедура производит инициализацию внутренних переменных и передаёт настройки. Содержит параметр `settings`, который является таблицей с полями:
* `dnsName` - обязательное поле, доменное имя, на которое получаем сертификат;
* `certPath` - обязательное поле, полный путь до папки с сертификатами;
* `certName` - не обязательное, по умолчанию = `cert.pem`, это имя файла, с которым будет создан сертификат;
* `csrName` - обязательное поле, имя созданного ранее файла запроса на подпись сертификата, и положенного в папку `certPath`;
* `challengeType` - не обязательное, по умолчанию = `http-01`, эта настройка показывает, какой тип проверки, что вы владеете доменом, будет использоваться. Всего доступно два варианта: `http01` и `dns01`. Первый тип проверки подтвержает владение, делая GET-запрос на определённый адрес сайта. Второй тип проверки делает DNS-запрос. Второй тип проверки нужен, если получаем сертификат на доменное имя сразу со всеми поддоменами: `*.domain.name` (wildcard-сертификаты). Подробнее можно поглядеть ниже в статье и [здесь](https://letsencrypt.org/ru/docs/challenge-types/ "здесь").
* `acmeDirectoryUrl` - не обязательное, по умолчанию = "https://acme-v02.api.letsencrypt.org/directory", это путь до входной точки ACME-сервера.

### onSetupChallengeHttp01
```
onSetupChallengeHttp01(url, body)
```
Данную процедуру необходимо переопределить, если использется проверка `http01`. Процедура будет вызвана, когда нужно будет установить ответ сервера. Сервер должен обязательно слушать 80-й порт, если получаем SSL-сертификат впервые. Или 443, если есть действующий SSL-сертификат. В момент вызова модуль передаст в качестве параметров:
* `url` - адрес, на который необходимо установить ответ. Это будет строка вида `'/.well-known/acme-challenge/%token`;
* `body` - текст, который необходимо вернуть при поступившем GET-запросе на указанный адрес.
  Процедура вызывается два раза - один раз для установки ответа, второй раз для отмены установки. Если `body` содержит текст, код ответа должен быть = 200. Если `body == nil`, тогда код ответа должен быть равен 404.

### onSetupChallengeDns01
```
onSetupChallengeDns01(key, value)
```
Данную процедуру необходимо переопределить, если использется проверка `dns01`. Процедура будет вызвана, когда нужно будет установить DNS-запись типа `TXT`. В момент вызова модуль передаст имя ключа `key` и его значение `value`, которое необходимо записать в DNS.
Процедура вызывается два раза - один раз для установки записи, второй раз для отмены установки (в параметре `value` будет передан nil).
Пример реализации этого типа проверки выходит за рамки данной статьи.

### getCert
```
getCert()
```
Данная процедура запускает процесс автоматического получения сертификата. Она не содержит параметров.

# Пример использования модуля
В примере используется внешний модуль - [http.server](https://github.com/tarantool/http "http.server").
``` lua
    local server = require('http.server').new("123.45.67.89", 80) -- 123.45.67.89 - внутренний ip сервера, 80 - номер прослушиваемого порта
    local acmeClient = require("acme-client")
    acmeClient:init(settings)

    acmeClient.onSetupChallengeHttp01 = function (url, body)
        local proc = nil
        if body ~= nil then
            proc = function (request)
                return {
                    status = 200,
					headers = {["content-type"] = "text/plain"},
                    body = body
                }
            end
        else
            proc = function (request)
                return { status = 404 }
            end
        end
        server:route({ path = url }, proc)
    end

    acmeClient:getCert()
```